<!DOCTYPE html>
<head>
  <meta charset = "utf-8">
  <title>InfoVis Project</title>
</head>
<body>
    <div id="button-div"></div>
    <div id="flex-outline">
      <div class="outline" id="entry-list-div">
        <svg id="entry-view"></svg>
      </div>
      <div class="outline" id="substitute-list-div">
        <svg id="substitute-svg"></svg>
      </div>
      <div class="outline" id="substitute-treemap-div">
        <div><select id="substitute-treemap-select"></select></div>
        <svg id="substitute-treemap-svg"></svg>
      </div>
      <div class="outline" id="gross-graph-div">
        <h2>엔트리 구성</h2>
        <svg id="gross-team-graph-svg"></svg><br>
        <svg id="gross-radar-graph-svg"></svg>
        <div><p></p></div>
      </div>
      <div class="outline" id="compare-graph-div">
        <h2>선수 정보</h2>
        <svg id="entry-profile"></svg>
        <svg id="substitute-profile"></svg>
        <svg id="compare-graph"></svg>
      </div>
    </div>

    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="radarChart.js" charset="utf-8"></script>

    <script>

      function translate(x, y) {
        return "translate(" + x + ", " + y + ")";
      }

      // team color list
      let hanwha_color = "#F37321";
      let doosan_color = "#131230";
      let sk_color = "#f20017";
      let heroes_color = "#820024";
      let nc_color = "#315288";
      let kia_color = "#c70125";
      let lg_color = "#c40452"
      let samsung_color = "#074ca1";
      let kkoltte_color = "#002955";
      let kt_color = "#000000";

      let entryhitter = [];
      let entrypitcher = [];

      let original_entryhitter = [];
      let original_entrypitcher = [];

      let is_hitter = true;

      // load data for hitter & pitcher
      Promise.all([
      d3.csv("./baseball/statiz/hitter/hitterfilter.csv"),
      d3.csv("./baseball/statiz/pitcher/pitcherposition.csv")
      ]).then(function(data) {

        function _entrylist(data) {
          let svg_width = 300;
          let svg_height = 900;
          let margin = 20;
          let width = svg_width - 2 * margin;
          let height = svg_height - 2 * margin;

          let entryview = d3.select("#entry-view").attr("width", width).attr("height", height)
                            .append("g").attr("transform", translate(margin, margin));

          let keys = ["이름", "팀", "포지션"];
          let thead = entryview.append("g").attr("class", "entry_thead");
          thead.selectAll("text").data(keys).enter().append("text").attr("transform", (d,i) => translate(i*80, 0)).text(d=>d);
          let tbody = entryview.append("g").attr("class", "entry_tbody").attr("transform", translate(0, 50));

          let rows = tbody.selectAll("g").data(data, t => t.이름);

          let new_rows = rows.enter().append("g").attr("class", t => t.이름)
                          .attr("transform", (d, i) => translate(0, i * 50))
                          .on("mouseover", function() {
                            let player = d3.select(this).data()[0].이름;
                            d3.selectAll("." + player).classed('hover', true);
                          })
                          .on("mouseout", function() {
                            let player = d3.select(this).data()[0].이름;
                            d3.selectAll("." + player).classed("hover", false);
                          })
                          .on("click.sub", sub_update) // update the substitue player. needs to be tweaked
                          .on("click.treemap", sub_treemap_update)
                          .on("click.graph",  entry_player_graph_update)
                          .selectAll("text").data(d=> keys.map(k=>[k, d[k]])).enter().append("text")
                          .text(d => d[1]).attr("transform", (d, i) => translate(i*80, 0));
        };

        // init will update every basic component when started
        init()
        function init() {

          // initialize the array for current entry
          let initial_hitter_entry = [1, 2, 3, 6, 8, 9, 10, 11, 16, 19, 21, 22, 30, 32, 41];
          let initial_pitcher_entry = [1, 3, 11, 19, 20, 22, 30, 38, 47, 49, 75, 78, 100];

          let selected_entry_player;
          let selected_sub_player;

          // make button for 
          let element = document.createElement("button");
          element.innerText = "투수로 전환";
          element.id = "switch-button";
          element.onclick = changeToPitcher;

          let button_div = document.getElementById("button-div");
          button_div.appendChild(element);




          function _initEntry() {
            // filtering out data and gives them order so that they can densly located
            // For now, data is ordered in 순. No need to update
            // but in update session, we need to sort the data(bcz data put / pop)
            entryhitter = data[0].filter(d => initial_hitter_entry.indexOf(Number(d.순)) !== -1);
            entrypitcher = data[1].filter(d => initial_pitcher_entry.indexOf(Number(d.순)) !== -1);

            original_entryhitter = [...entryhitter];
            original_entrypitcher = [...entrypitcher];
          }
          _initEntry();


          _entrylist(entryhitter);


          function _substitutelist() {

            let svg_width = 200;
            let svg_height = 2500;
            let margin = 20;
            let width = svg_width - 2 * margin;
            let height = svg_height - 2 * margin;

            let subview = d3.select("#substitute-svg").attr("width", width).attr("height", height)
                            .append("g").attr("transform", translate(margin, 0));

            let keys = ["이름", "팀"];
            let thead = subview.append("g");
            thead.selectAll("text").data(keys).enter().append("text").attr("transform", (d, i) => translate(i*80, 0)).text(d => d);


          };
          _substitutelist();


          function _substitutetreemap() {
            let svg_width = 600;
            let svg_height = 750;
            let margin = 20;
            let width = svg_width - 2 * margin;
            let height = svg_height - 2 * margin;

            let treemap_view = d3.select("#substitute-treemap-svg").attr("width", width).attr("height", height)
                                                .append("g").attr("transform", translate(margin, margin));
            treemap_view.append("text").text("선수를 클릭하면 같은 포지션의 선수를 보여주는 그래프가 표시됩니다");
          }
          _substitutetreemap();


          // The function will initiate the gross graph slot
          function _teamgraph() {

            let svg_width = 250;
            let svg_height = 100;
            let margin = 10;
            let width = svg_width - 2 * margin;
            let height = svg_height - 2 * margin;

            // this part, we will make stacked bar chart
            let teamcount = countTeam(entryhitter);
            console.log(teamcount);

            let teamgraph = d3.select("#gross-team-graph-svg").attr("width", width).attr("height", height)
                              .append("g").attr("transform", translate(margin, margin));

            let barx = d3.scaleLinear()
                          .domain([0, 100])
                          .rangeRound([0, width])
            
            // put plain text at the title section
            let team_text = teamgraph.append("g").attr("class", "teamgraph-text").attr("translate", translate(margin, margin));
            team_text.append("text")
                        .attr("class", "teamgraph-title-text")
                        .attr("y", 30)
                        .text("팀 분포")
                        .style("font-size", "20px")
                        .style("font-weight", 'bold');

            team_text.append("text")
                      .attr("class", "teamgraph-content-text1")
                      .attr("y", 150)
                      .text(teamcount[0].team + "이 최다로 현재 " + (teamcount[0].count / entryhitter.length * 100).toFixed(2) +"%를")
            team_text.append("text")
                      .attr("class", "teamgraph-content-text2")
                      .attr("y", 170)
                      .text("차지하고 있습니다")

            let xAxis = d3.axisBottom(barx);
            
            let total = margin;
            teamgraph.selectAll("rect").data(teamcount, d => d.team)
                    .enter().append("rect")
                    .attr("class", "team-proportion-rect")
                    .attr("x", function(d) {
                      let value = barx(d.count / entryhitter.length * 100);
                      total += value;
                      return total - value})
                    .attr("y", 50)
                    .attr("width", function(d) {return barx(d.count / entryhitter.length * 100)})
                    .attr("height", 30)
                    .style('fill', d => teamColor(d.team))
                    .on("mouseenter", function(d) {
                      tooltip.style("display", null);
                      let xPosition = d3.mouse(this)[0] - 15;
                      var yPosition = d3.mouse(this)[1] - 25;
                      tooltip.attr("transform", translate(xPosition, yPosition));
                      tooltip.select("text").text(d.team + ": " + d.count);

                      d3.select(this).style("stroke-width", 2)
                        .style("stroke", "#ffffff");
                    })
                    .on("mouseleave", function() {
                      tooltip.style("display", "none");

                      d3.select(this).style("stroke-width", 0)
                    })
                    

            teamgraph.append("g")
              .attr("class", "BarX")
              .attr("transform", translate(margin, margin + height))
              .call(xAxis);

            // make tooltip for graph
            let tooltip = teamgraph.append("g")
                                  .attr("class", "tooltip")
                                  .style("display", "none");

            tooltip.append("rect")
                  .attr("width", 40)
                  .attr("height", 20)
                  .attr("fill", "white")
                  .style("opacity", 0.8)
            
            
            tooltip.append("text")
                  .attr("x", 20)
                  .attr("dy", "1.2em")
                  .style("text-anchor", "middle")
                  .attr("font-size", "12px")
                  .attr("font-weight", "bold");
            // end of tooltip append

          }
          _teamgraph();
        
          // this graph will make gross SABR graph for hitter
          function _grossRadarGraph() {
            let width = 300;
            let height = 300;
            let margin = 0;

            let radargraph = d3.select("#gross-radar-graph-svg").attr("width", width).attr("height", height)
                                .append("g").attr("transform", translate(margin, margin));        

            // 이제 여기에 radar graph
            let radar_data = [
              {
                name: 'KBO Hitter Entry',
                axes: [
                  {axis: 'OPS', value: entryhitter.reduce((accum, current) => accum + Number(current['OPS']), 0) },
                  {axis: 'OBP(출루율)', value: entryhitter.reduce((accum, current) => accum + Number(current['출루']), 0) },
                  {axis: 'wOBA', value: entryhitter.reduce((accum, current) => accum + Number(current['wOBA']), 0) },
                ],
                color: '#26AF32'
              }
            ]

            let radaroptions = {
              w: 250,
              h: 200,
              margin: { top: 30, right: 30, bottom: 30, left: 30 },
              levels: 3,
              roundStrokes: false,
              color: d3.scaleOrdinal().range(["#26AF32"]),
              format: '.3f'
            }

            RadarChart("#gross-radar-graph-svg", radar_data, radaroptions);
          
          }
          _grossRadarGraph();

          // This initiate the first svg of entry player
          function _entry_player_graph() {
            let svg_width = 800;
            let svg_height = 500;
            let margin = 20;
            let width = svg_width - 2 * margin;
            let height = svg_height - 2 * margin;

            let entry_player_graph = d3.select("#entry-profile").attr("width", width).attr("height", height)
                                        .append("g").attr("transform", translate(margin, margin)).attr("fill", "blue");

          }

        }
        ////////////////
        // end of init//
        ////////////////

        ////////////////////
        // start of update//
        ///////////////////

        // this function makes sub list updated when each player is clicked
        function sub_update() {

          d3.select("#substitute-svg").selectAll("g").remove()

          let svg_width = 200;
          let svg_height = 2500;
          let margin = 20;
          let width = svg_width - 2 * margin;
          let height = svg_height - 2 * margin;

          let subview = d3.select("#substitute-svg").attr("width", width).attr("height", height)
                          .append("g").attr("transform", translate(margin, margin));

          let keys = ["이름", "팀"];

          let thead = subview.append("g");
          thead.selectAll("text").data(keys).enter().append("text").attr("transform", (d,i) => translate(i*80, 0)).text(d=>d);
          let tbody = subview.append("g").attr("transform", translate(0, 50));
          

          // 타자인 경우에는 포지션이 맞는 선수를 제시
          let subdata;
          if (is_hitter) {
            // hitters of substitutes should have same position but not include player in entry
            subdata = data[0].filter(item => item.포지션 === d3.select(this).data()[0].포지션 && !entryhitter.includes(item));
          }
          // 투수인 경우에는 선발==0 인 선수를 불펜으로 분류하고 아니면 선발로 제시
          else {
            subdata = data[1].filter(item => item.포지션 === d3.select(this).data()[0].포지션 && !entrypitcher.includes(item));
          }

          let rows = tbody.selectAll("g").data(subdata, t => t.이름);
          rows.selectAll('text').data(d => keys.map(k => [k, d[k]])).text(d => d[1])

          let new_rows = rows.enter().append("g").attr("class", t => t.이름)
                        .attr("transform", (d, i) => translate(0, i * 50))
                        .on("mouseover", function() {
                          let player = d3.select(this).data()[0].이름;
                          d3.selectAll("." + player).classed("hover", true);
                        })
                        .on("mouseout", function() {
                          let player = d3.select(this).data()[0].이름;
                          d3.selectAll("." + player).classed("hover", false);
                        })
                        .on("click", sub_graph_update_for_list)
                        .selectAll("text").data(d=> keys.map(k=>[k, d[k]])).enter().append("text")
                        .text(d => d[1]).attr("transform", (d, i) => translate(i*80, 0));

        }

        // This function will update sub_treemap
        // 현재 각 수치가 음수거나 0인 경우에 깨지는 문제가 있다... 다른 거로 교체하든가.. 아니면 양수인 선수만 넣든가...해야할듯...
        function sub_treemap_update() {
          // resetting previously set stats
          d3.select("#substitute-treemap-svg").selectAll("g").remove();
          document.getElementById("substitute-treemap-select").options.length = 0;


          let select_stat = d3.select("#substitute-treemap-select");
          let hitter_option = Object.keys(entryhitter[0]).filter(d => 
              d !== "순" &&
              d !== "이름" &&
              d !== "년도" &&
              d !== "팀" &&
              d !== "포지션"
            );
          let pitcher_option = Object.keys(entrypitcher[0]).filter(d => 
              d !== "순" &&
              d !== "이름" &&
              d !== "팀" &&
              d !== "포지션"
          );
          if (is_hitter) {
            select_stat.selectAll("option").data(hitter_option).enter().append("option").text(d => d);
          }
          else {
            select_stat.selectAll("option").data(pitcher_option).enter().append("option").text(d => d);
          }

          let width = 800;
          let height = 750;
          let margin = 20;

          let treemap_view = d3.select("#substitute-treemap-svg").attr("width", width).attr("height", height)
                                              .append("g");

          let root;
          let tier_data;
          if (is_hitter) {
            tier_data = data[0].filter(item => item.포지션 === d3.select(this).data()[0].포지션);
            
            tier_data.push({이름: "top", 팀: null})
            tier_data.push({이름: "한화", 팀: "top"});
            tier_data.push({이름: "kt", 팀: "top"});
            tier_data.push({이름: "두산", 팀: "top"});
            tier_data.push({이름: "SK", 팀: "top"});
            tier_data.push({이름: "KIA", 팀: "top"});
            tier_data.push({이름: "삼성", 팀: "top"});
            tier_data.push({이름: "LG", 팀: "top"});
            tier_data.push({이름: "NC", 팀: "top"});
            tier_data.push({이름: "롯데", 팀: "top"});
            tier_data.push({이름: "키움", 팀: "top"});


            root = d3.stratify()
                      .id(d => d.이름)
                      .parentId(d => d.팀)
                      (tier_data);
            root.sum(d => Number(d['안타']));
            
          }
          else {
            let tier_data = data[1].filter(item => item.포지션 === d3.select(this).data()[0].포지션);
            
            tier_data.push({이름: "top", 팀: null})
            tier_data.push({이름: "한화", 팀: "top"});
            tier_data.push({이름: "kt", 팀: "top"});
            tier_data.push({이름: "두산", 팀: "top"});
            tier_data.push({이름: "SK", 팀: "top"});
            tier_data.push({이름: "KIA", 팀: "top"});
            tier_data.push({이름: "삼성", 팀: "top"});
            tier_data.push({이름: "LG", 팀: "top"});
            tier_data.push({이름: "NC", 팀: "top"});
            tier_data.push({이름: "롯데", 팀: "top"});
            tier_data.push({이름: "키움", 팀: "top"});

            root = d3.stratify()
                      .id(d => d.이름)
                      .parentId(d => d.팀)
                      (tier_data);
            root.sum(d => Number(d['WAR']));
          }


          d3.treemap()
              .size([width - margin, height - margin])
              .paddingInner(1)
              (root);

          let tooltip = d3.select('body')
                  .append('div')
                  .attr('id', 'tooltip')
                  .attr('width', 60 + 'px')
                  .attr('height', 40 + 'px')
                  .style('z-index', 10)
                  .style('background', 'white')
                  .style('display', 'none')
                  .style('position', 'absolute');


          treemap_view.selectAll("rect")
                        .data(root.leaves(), d => d.data.이름)
                        .enter()
                        .append("rect")
                        .attr("class", "treemaprect")
                        .attr("id", d => "rect" + d.data.이름)
                        .attr("x", d => d.x0)
                        .attr("y", d => d.y0)
                        .attr("width", d => d.x1 - d.x0)
                        .attr("height", d => d.y1 - d.y0)
                        .style("fill", d => teamColor(d.data.팀))
                        .on("click", sub_graph_update_for_treemap)
                        .on('mouseover', d => {
                          d3.select("#rect" + d.data.이름).style("stroke", "white")
                                                          .style("stroke-width", 3);

                          const tooltipText = formatTooltip(d);
                          tooltip.transition().duration(200)
                                .style('position', 'absolute')
                                .style('display', 'block');
                          tooltip.html(tooltipText)
                                .attr('data-value', d.value)
                                .style('top', (d3.event.pageY - 50) + 'px')
                                .style('left', (d3.event.pageX + 20) + 'px');
                        })
                        .on('mouseout', d => {
                          d3.select("#rect" + d.data.이름).style("stroke", null)

                          tooltip.transition().duration(500)
                                .style('display', 'none');
                        });

          treemap_view.selectAll("text")
                        .data(root.leaves(), d => d.data.이름)
                        .enter()
                        .append("text")
                        .attr("id", d => "text" + d.data.이름)
                        .attr("x", d => d.x0 + 10)
                        .attr("y", d => d.y0 + 15)
                        .text(d => d.data.이름)
                        .style("font-size", "12px")
                        .style("opacity", d => {
                          let bbox = d3.select("#text" + d.data.이름).node().getBBox();

                          if (d3.select("#rect" + d.data.이름).attr("width") <= bbox.width + 5 || d3.select("#rect" + d.data.이름).attr("height") <= bbox.height + 5) {
                            return 0;
                          }
                          return 1;
                        })
                        .style("fill", "white")
                        .on("click", sub_graph_update_for_treemap)
                        .on('mouseover', d => {

                          const tooltipText = formatTooltip(d);
                          tooltip.transition().duration(200)
                                .style('position', 'absolute')
                                .style('display', 'block');
                          tooltip.html(tooltipText)
                                .attr('data-value', d.value)
                                .style('top', (d3.event.pageY - 50) + 'px')
                                .style('left', (d3.event.pageX + 20) + 'px');
                          })
                        .on('mouseout', d => {

                          tooltip.transition().duration(500)
                                .style('display', 'none');
                        });


          // 만일 select의 값이 바뀌면 호출되어서 transition을 한다
          select_stat.on("change", () => sub_treemap_update_on_select(tier_data));

        }


        function formatTooltip(d) {
          const name = d.data.이름,
                stat_item = d3.select("#substitute-treemap-select").property('value');
                value = d.data[stat_item],
                tooltipText = `
                    ${name} <br>
                    <span>${stat_item}:</span> ${value} <br>`;

          return tooltipText;
        }


        function sub_treemap_update_on_select(tier_data) {
          let width = 800;
          let height = 750;
          let margin = 20;

          let select_stat = d3.select("#substitute-treemap-select");
          let stat_item = select_stat.property('value');
          console.log(stat_item);

          /* 왠지 안돼서 일단 놔두고 그냥 새로 만들기 할거임
          let root = d3.stratify()
                        .id(d => d.이름)
                        .parentId(d => d.팀)
                        (tier_data);
          root.sum(d => Number(d[stat_item]));

          d3.treemap()
            .size([width - margin])
            .paddingInner(1)
            (root);
          let treemap_view = d3.select("#substitute-treemap-svg").select("g");


          treemap_view.selectAll("rect")
                        .data(root.leaves(), d => d.data.이름)
                        .transition().duration(1000)
                        .attr("x", d => d.x0)
                        .attr("y", d => d.y0)
                        .attr("width", d => d.x1 - d.x0)
                        .attr("height", d => d.y1 - d.y0)
                        .style("fill", d => teamColor(d.data.팀));

          treemap_view.selectAll("text")
                        .data(root.leaves())
                        .transition().duration(1000)
                        .attr("x", d => d.x0 + 10)
                        .attr("y", d => d.y0 + 15)
          */
          d3.select("#substitute-treemap-svg").select("g").remove();
          let treemap_view = d3.select("#substitute-treemap-svg").attr("width", width).attr("height", height)
                                              .append("g");

          let root;
          //let tier_data;
          if (is_hitter) {
            /*
            tier_data = data[0].filter(item => item.포지션 === d3.select(this).data()[0].포지션);
            
            tier_data.push({이름: "top", 팀: null})
            tier_data.push({이름: "한화", 팀: "top"});
            tier_data.push({이름: "kt", 팀: "top"});
            tier_data.push({이름: "두산", 팀: "top"});
            tier_data.push({이름: "SK", 팀: "top"});
            tier_data.push({이름: "KIA", 팀: "top"});
            tier_data.push({이름: "삼성", 팀: "top"});
            tier_data.push({이름: "LG", 팀: "top"});
            tier_data.push({이름: "NC", 팀: "top"});
            tier_data.push({이름: "롯데", 팀: "top"});
            tier_data.push({이름: "키움", 팀: "top"});
            */


            root = d3.stratify()
                      .id(d => d.이름)
                      .parentId(d => d.팀)
                      (tier_data);
            root.sum(d => Number(d[stat_item]));
            
          }
          else {
            /*
            let tier_data = data[1].filter(item => item.포지션 === d3.select(this).data()[0].포지션);
            
            tier_data.push({이름: "top", 팀: null})
            tier_data.push({이름: "한화", 팀: "top"});
            tier_data.push({이름: "kt", 팀: "top"});
            tier_data.push({이름: "두산", 팀: "top"});
            tier_data.push({이름: "SK", 팀: "top"});
            tier_data.push({이름: "KIA", 팀: "top"});
            tier_data.push({이름: "삼성", 팀: "top"});
            tier_data.push({이름: "LG", 팀: "top"});
            tier_data.push({이름: "NC", 팀: "top"});
            tier_data.push({이름: "롯데", 팀: "top"});
            tier_data.push({이름: "키움", 팀: "top"});
            */

            root = d3.stratify()
                      .id(d => d.이름)
                      .parentId(d => d.팀)
                      (tier_data);
            root.sum(d => Number(d[stat_item]));
          }


          d3.treemap()
              .size([width - margin, height - margin])
              .paddingInner(1)
              (root);

          d3.selectAll("#treemap_tooltip").remove();

          let tooltip = d3.select('body')
                  .append('div')
                  .attr('id', 'treemap_tooltip')
                  .attr('width', 60 + 'px')
                  .attr('height', 40 + 'px')
                  .style('z-index', 10)
                  .style('background', 'white')
                  .style('display', 'none')
                  .style('position', 'absolute');


          treemap_view.selectAll("rect")
                        .data(root.leaves(), d => d.data.이름)
                        .enter()
                        .append("rect")
                        .attr("class", "treemaprect")
                        .attr("id", d => "rect" + d.data.이름)
                        .attr("x", d => d.x0)
                        .attr("y", d => d.y0)
                        .attr("width", d => d.x1 - d.x0)
                        .attr("height", d => d.y1 - d.y0)
                        .style("fill", d => teamColor(d.data.팀))
                        .on("click", sub_graph_update_for_treemap)
                        .on('mouseover', d => {
                          d3.select("#rect" + d.data.이름).style("stroke", "white")
                                                          .style("stroke-width", 3);

                          const tooltipText = formatTooltip(d);
                          tooltip.transition().duration(200)
                                .style('position', 'absolute')
                                .style('display', 'block');
                          tooltip.html(tooltipText)
                                .attr('data-value', d.value)
                                .style('top', (d3.event.pageY - 50) + 'px')
                                .style('left', (d3.event.pageX + 20) + 'px');
                        })
                        .on('mouseout', d => {
                          d3.select("#rect" + d.data.이름).style("stroke", null)

                          tooltip.transition().duration(500)
                                .style('display', 'none');
                        });

          treemap_view.selectAll("text")
                        .data(root.leaves(), d => d.data.이름)
                        .enter()
                        .append("text")
                        .attr("id", d => "text" + d.data.이름)
                        .attr("x", d => d.x0 + 10)
                        .attr("y", d => d.y0 + 15)
                        .text(d => d.data.이름)
                        .style("font-size", "12px")
                        .style("opacity", d => {
                          let bbox = d3.select("#text" + d.data.이름).node().getBBox();
                          if (d3.select("#rect" + d.data.이름).attr("width") <= bbox.width + 5 || d3.select("#rect" + d.data.이름).attr("height") <= bbox.height + 5) {
                            return 0;
                          }
                          return 1;
                        })
                        .style("fill", "white")
                        .on("click", sub_graph_update_for_treemap)
                        .on('mouseover', d => {

                          const tooltipText = formatTooltip(d);
                          tooltip.transition().duration(200)
                                .style('position', 'absolute')
                                .style('display', 'block');
                          tooltip.html(tooltipText)
                                .attr('data-value', d.value)
                                .style('top', (d3.event.pageY - 50) + 'px')
                                .style('left', (d3.event.pageX + 20) + 'px');
                        })
                        .on('mouseout', d => {

                          tooltip.transition().duration(500)
                                .style('display', 'none');
                        });


          // 만일 select의 값이 바뀌면 호출되어서 transition을 한다
          select_stat.on("change", () => sub_treemap_update_on_select(tier_data));

        }


        // this function updates graph for entry player
        // this includes team percentage and radar graph
        function entry_player_graph_update() {
          // 엔트리 목록이 바뀌었으므로 비교가 무의미 sub_player와 graph의 내용도 지워버리도록 하자
          d3.select("#substitute-profile").selectAll("g").remove();
          d3.select("#compare-graph").selectAll("g").remove();

          let entry_player_graph = d3.select("#entry-profile");
          entry_player_graph.selectAll("g").remove();

          let player = d3.select(this).data()[0];
          selected_entry_player = player.순;

          let margin = 20;
          let player_svg = entry_player_graph.append("g").attr("transform", translate(margin, margin)).selectAll("text").data([player]).enter();

          player_svg.append("text").attr("transform", translate(margin + 94, margin)).attr("id", "entry_player_name_text").text(d => d.이름);
          player_svg.append("image").attr("href", "image/" + player.이름 + ".jpg")
            .on("error", function () {
              d3.select(this).attr("href", "image/default.png").attr("width", 94);
            });


          // variable for radar chart
          let height = 300;


          let radaroptions = {
              w: 300,
              h: 200,
              margin: { top: 50, right: 30, bottom: 30, left: 50 },
              levels: 3,
              roundStrokes: false,
              color: d3.scaleOrdinal().range(["#26AF32"]),
              format: '.3f'
          };

          let name = player.이름;
          let axes;
          let color = "#26AF32";

          // update stat chart according to the is_hitter
          if (is_hitter) {
            let keys = ["WAR*", "OPS", "출루", "wOBA"];
            let thead = player_svg.append("g").attr("transform", translate(200, 0));
            thead.selectAll("text").data(keys).enter().append("text").attr("transform", (d, i) => translate(i * 80, 0)).text(d => d);
            let tbody = player_svg.append("g").attr("transform", translate(200, 50));
            let rows = tbody.append("g").data(player);

            let new_rows = tbody.selectAll("g").attr("class", d => d.이름)
                .attr("transform", (d, i) => translate(0, i * 50))
                .selectAll("text").data(d => keys.map(k => [d, d[k]])).enter().append("text")
                .text(d => d[1]).attr("transform", (d, i) => translate(i * 80, 0));

            // make radar graph for pitcher
            axes = [
                {axis: 'OPS', value: Number(player['OPS']) },
                {axis: '출루', value: Number(player.출루) },
                {axis: 'wOBA', value: Number(player.wOBA) },
            ];
          }
          else {
            let keys = ["ERA", "FIP", "BB/9"];
            let thead = player_svg.append("g").attr("transform", translate(200, 0));
            thead.selectAll("text").data(keys).enter().append("text").attr("transform", (d, i) => translate(i * 80, 0)).text(d => d);
            let tbody = player_svg.append("g").attr("transform", translate(200, 50));
            let rows = tbody.append("g").data(player);

            let new_rows = tbody.selectAll("g").attr("class", d => d.이름)
                .attr("transform", (d, i) => translate(0, i * 50))
                .selectAll("text").data(d => keys.map(k => [d, d[k]])).enter().append("text")
                .text(d => d[1]).attr("transform", (d, i) => translate(i * 80, 0));

            // update radar graph for pitcher
            axes = [
                {axis: 'ERA', value: Number(player.ERA) },
                {axis: 'FIP', value: Number(player.FIP) },
                {axis: 'BB/9', value: Number(player['BB/9']) },
            ]
          }
          RadarChart("#compare-graph", [{name: name, axes: axes, color: color}], radaroptions)

        }

        function sub_graph_update_for_list() {
          let player = d3.select(this).data()[0];


          sub_graph_update(player);
        }

        function sub_graph_update_for_treemap() {
          let entry_player = d3.select("#entry_player_name_text").data()[0];
          let player = d3.select(this).data()[0].data;
          
          if (entry_player.순 === player.순) {
            alert("엔트리 참가 선수를 다시 선택할 수 없습니다")
            return;
          }

          sub_graph_update(player);
        }
        
        // this function updates graph for substitute player
        // this includes radar graph, and player stat table
        function sub_graph_update(player) {
          // sub graph update가 바뀌었으므로 비교 그래프를 지운다
          d3.select("compare-graph").selectAll("g").remove();

          let sub_player_graph = d3.select("#substitute-profile");
          sub_player_graph.selectAll("g").remove();

          console.log(player);
          selected_sub_player = player.순;

          let margin = 20;
          let player_svg = sub_player_graph.append("g").attr("transform", translate(margin, margin)).selectAll("text").data([player]).enter();

          player_svg.append("text").attr("transform", translate(margin + 94, margin)).attr("id", "substitute_player_name_text").text(d => d.이름);
          player_svg.append("image").attr("href", "image/" + player.이름 + ".jpg")
            .on("error", function () {
              d3.select(this).attr("href", "image/default.png").attr("width", 94);
            });


          let radaroptions = {
              w: 300,
              h: 200,
              margin: { top: 50, right: 30, bottom: 30, left: 50 },
              levels: 3,
              roundStrokes: false,
              color: d3.scaleOrdinal().range(["#26AF32", "#5c7aff"]),
              format: '.3f'
          };

          let name = player.이름;
          let axes;
          let color = "#5c7aff";

          // update stat according to is_hitter 
          if (is_hitter) {
            let keys = ["WAR*", "OPS", "출루", "wOBA"];
            let thead = player_svg.append("g").attr("transform", translate(200, 0));
            thead.selectAll("text").data(keys).enter().append("text").attr("transform", (d, i) => translate(i * 80, 0)).text(d => d);
            let tbody = player_svg.append("g").attr("transform", translate(200, 50));
            let rows = tbody.append("g").data(player);

            let new_rows = tbody.selectAll("g").attr("class", d => d.이름)
                .attr("transform", (d, i) => translate(0, i * 50))
                .selectAll("text").data(d => keys.map(k => [d, d[k]])).enter().append("text")
                .text(d => d[1]).attr("transform", (d, i) => translate(i * 80, 0));

            // make radar graph for pitcher
            axes = [
                {axis: 'OPS', value: Number(player['OPS']) },
                {axis: '출루', value: Number(player.출루) },
                {axis: 'wOBA', value: Number(player.wOBA) },
            ];
          }
          else {
            let keys = ["ERA", "FIP", "BB/9"];
            let thead = player_svg.append("g").attr("transform", translate(200, 0));
            thead.selectAll("text").data(keys).enter().append("text").attr("transform", (d, i) => translate(i * 80, 0)).text(d => d);
            let tbody = player_svg.append("g").attr("transform", translate(200, 50));
            let rows = tbody.append("g").data(player);

            let new_rows = tbody.selectAll("g").attr("class", d => d.이름)
                .attr("transform", (d, i) => translate(0, i * 50))
                .selectAll("text").data(d => keys.map(k => [d, d[k]])).enter().append("text")
                .text(d => d[1]).attr("transform", (d, i) => translate(i * 80, 0));

            // update radar graph for pitcher
            axes = [
                {axis: 'ERA', value: Number(player.ERA) },
                {axis: 'FIP', value: Number(player.FIP) },
                {axis: 'BB/9', value: Number(player['BB/9']) },
            ];
          }

          entry_data = d3.select("#compare-graph").select(".radarWrapper").data()[0]
          RadarChart("#compare-graph", [entry_data, {name: name, axes: axes, color: color}], radaroptions)

          // add a rect to work as button
          let compare_svg = d3.select("#compare-graph").append("g")
          let compare_button = compare_svg.append("rect").attr("x", 400).attr("y", 100)
                                    .attr("height", 50).attr("width", 100)
                                    .style("fill", "#d4d4d4")
                                    .on("click", swap_player);

          compare_svg.append("text")
                          .attr("x", 450)
                          .attr("y", 125)
                          .style("text-anchor", "middle")
                          .text("교체")
                          .on("click", swap_player);
                          //.style("text-anchor", "middle");

        }

        // 이 함수는 선택한 엔트리 선수와 대체 선수를 교체합니다
        function swap_player() {
          let entry_player = d3.select("#entry_player_name_text").data()[0];
          let substitute_player = d3.select("#substitute_player_name_text").data()[0];

          // update entry array and table view
          let sub_player_data;

          let tbody_view = d3.select(".entry_tbody");
          let keys = ["이름", "팀", "포지션"];
          let rows;

          if (is_hitter) {
            sub_player_data = data[0].filter(d => d.순 === substitute_player.순);
            entryhitter.map((d, i) => {
            if (d.순 === entry_player.순) {
                entryhitter[i] = sub_player_data[0]};
            });
            entryhitter.sort((a, b) => Number(a.순) - Number(b.순));

            // 표를 다시 만들기. enter & update합시다
            rows = tbody_view.selectAll("g").data(entryhitter, d => d.이름);
            rows.selectAll("text").data(d => keys.map(k => ([k, d[k]]))).text(d => d[1]);
            rows.transition().duration(1000).attr("transform", (d, i) => translate(0, i * 50));

          }
          else {
            sub_player_data = data[1].filter(d => d.순 === substitute_player.순);
            entrypitcher.map((d, i) => {
              if (d.순 === entry_player.순) {
                entrypitcher[i] = sub_player_data[0]};
              });
            entrypitcher.sort((a, b) => Number(a.순) - Number(b.순));

            rows = tbody_view.selectAll("g").data(entrypitcher, d => d.이름);
            rows.selectAll("text").data(d => keys.map(k => [k, d[k]])).text(d => d[1]);
            rows.transition().duration(1000).attr("transform", (d, i) => translate(0, i * 50));
          }

          let new_rows = rows.enter().append("g").attr("class", d => d.이름)
              .attr("transform", (d, i) => translate(0, i * 50))
              .style("opacity", 0)
              .on('mouseover', function(){
                let player = d3.select(this).data()[0].이름
                d3.selectAll("." + player).classed('hover', true)
              })
              .on('mouseout', function(){
                let player = d3.select(this).data()[0].이름
                d3.selectAll("." + player).classed('hover', false)
              })
              .on("click.sub", sub_update) // update the substitue player. needs to be tweaked
              .on("click.graph",  entry_player_graph_update);

          new_rows.selectAll('text').data(d=>keys.map(k=>[k,d[k]])).enter().append('text')
              .text(d=>d[1]).attr("transform", (d, i) => translate(i*80, 0));
          new_rows.transition().duration(1000).delay(1000).style("opacity", 1);
          // remove exited rows
          rows.exit().remove();

          // end of updating table view

          // update team graph
          team_graph_update();

          // update gross graph
          gross_radar_graph_update();


        }

        // 이 함수는 전체 통계 수치가 어떻게 변화하는지를 확인해줍니다(radar map 형태로)
        function gross_radar_graph_update() {
          let radargraph = d3.select("#gross-radar-graph-svg");

          let radaroptions = {
              w: 300,
              h: 200,
              margin: { top: 30, right: 30, bottom: 30, left: 30 },
              levels: 3,
              roundStrokes: false,
              color: d3.scaleOrdinal().range(["#5c7aff", "#26AF32"]),
              format: '.3f'
            };

          let color = '#26AF32';
          let name;
          let axes;
          let maxValue;

          //지금은 직전 데이터 비교하는데 생각해보니까 처음 데이터랑 비교하는 게 더 좋을듯
          let old_data;
          let old_name = "Stat before";
          let old_color = "#5c7aff";

          if (is_hitter) {
            old_data = [
              {axis: 'OPS', value: original_entryhitter.reduce((accum, current) => accum + Number(current['OPS']), 0) },
              {axis: 'OBP(출루율)', value: original_entryhitter.reduce((accum, current) => accum + Number(current['출루']), 0) },
              {axis: 'wOBA', value: original_entryhitter.reduce((accum, current) => accum + Number(current['wOBA']), 0) },
            ];

            name = 'KBO Hitter Entry';
            axes = [
                {axis: 'OPS', value: entryhitter.reduce((accum, current) => accum + Number(current['OPS']), 0) },
                {axis: 'OBP(출루율)', value: entryhitter.reduce((accum, current) => accum + Number(current['출루']), 0) },
                {axis: 'wOBA', value: entryhitter.reduce((accum, current) => accum + Number(current['wOBA']), 0) },
              ];

          }
          else {
            old_data = [
              {axis: 'ERA', value: original_entrypitcher.reduce((accum, current) => accum + Number(current['ERA']), 0) },
              {axis: 'FIP', value: original_entrypitcher.reduce((accum, current) => accum + Number(current['FIP']), 0) },
              {axis: 'BB/9', value: original_entrypitcher.reduce((accum, current) => accum + Number(current['BB/9']), 0) },
            ];

            name = 'KBO Pitcher Entry';
            axes = [
                {axis: 'ERA', value: entrypitcher.reduce((accum, current) => accum + Number(current['ERA']), 0) },
                {axis: 'FIP', value: entrypitcher.reduce((accum, current) => accum + Number(current['FIP']), 0) },
                {axis: 'BB/9', value: entrypitcher.reduce((accum, current) => accum + Number(current['BB/9']), 0) },
            ]
          }

          RadarChart("#gross-radar-graph-svg", [{name: old_name, axes: old_data, color: old_color}, {name: name, axes: axes, color: color}], radaroptions);

          /* vaiables to use at transition
          let allExis = axes.map((i, j) => i.axis);
          let total = 
          */
        }

        // 이 함수는 엔트리 교체를 했을 시 각 팀의 점유율이 어떻게 되는지 정의합니다
        function team_graph_update() {

          let svg_width = 250;
          let svg_height = 100;
          let margin = 10;
          let width = svg_width - 2 * margin;
          let height = svg_height - 2 * margin;

          // this part, we will make stacked bar chart
          let teamcount;
          let length;
          if (is_hitter) {
            teamcount = countTeam(entryhitter);
            length = entryhitter.length;
          }
          else {
            teamcount = countTeam(entrypitcher);
            length = entrypitcher.length;
          }

          let teamgraph = d3.select("#gross-team-graph-svg").select("g");

          let barx = d3.scaleLinear()
                        .domain([0, 100])
                        .rangeRound([0, width])

          // put plain text at the title section
          console.log(teamcount);
          if (teamcount[0].team === "두산" || teamcount[0].team === "키움" || teamcount[0].team === "삼성") {
            d3.select(".teamgraph-content-text1").text(teamcount[0].team + "이 최다로 현재 " + (teamcount[0].count / length * 100).toFixed(2) +"%를");
          }
          else {
            d3.select(".teamgraph-content-text1").text(teamcount[0].team + "가 최다로 현재 " + (teamcount[0].count / length * 100).toFixed(2) +"%를");
          }

          let xAxis = d3.axisBottom(barx);
          let total = margin;

          let team_x = {};
          teamcount.forEach(element => {
            let value = barx(element.count / length * 100);
            total += value;
            team_x[element.team] = total - value;
          });

          let old_data = teamgraph.selectAll("rect").data();
          let bars = teamgraph.selectAll(".team-proportion-rect");
          bars.data(teamcount, d => d.team);

          bars
            .on("mouseenter", function(d) {
              tooltip.style("display", null);
              let xPosition = d3.mouse(this)[0] - 15;
              var yPosition = d3.mouse(this)[1] - 25;
              tooltip.attr("transform", translate(xPosition, yPosition));
              tooltip.select("text").text(d.team + ": " + d.count);

              // this will make outer stroke
              d3.select(this).style("stroke-width", 2)
                .style("stroke", "#ffffff");
            })
            .on("mouseleave", function() {
              tooltip.style("display", "none");

              d3.select(this).style("stroke-width", 0);
            })
            .transition()
            .attr("x", function(d) {
              return team_x[d.team];
            })
            .attr("width", function(d) {return barx(d.count / length * 100)})
              
          bars.exit().remove();


          // make tooltip for graph
          let tooltip = teamgraph.select(".tooltip")
          tooltip.select("text").remove();
                    
          tooltip.append("rect")
                .attr("width", 40)
                .attr("height", 20)
                .attr("fill", "white")
                .style("opacity", 0.8)

          tooltip.append("text")
            .attr("x", 20)
            .attr("dy", "1.2em")
            .style("text-anchor", "middle")
            .attr("font-size", "12px")
            .attr("font-weight", "bold");

          // end of tooltip append

        }


        ///////////////////
        // end of update //
        ///////////////////

        function teamColor(team) {
          switch (team) {
            case "한화":
              return hanwha_color;
            case "두산":
              return doosan_color;
            case "키움":
              return heroes_color;
            case "롯데":
              return kkoltte_color;
            case "삼성":
              return samsung_color;
            case "LG":
              return lg_color;
            case "kt":
              return kt_color;
            case "KIA":
              return kia_color;
            case "NC":
              return nc_color;
            case "SK":
              return sk_color;
            default:
              console.log("in teamColor(), no match was found!!");
          }
        }

        // this function counts the team and returns the dictionary of each count.
        function countTeam(entry) {
          let teamcount = [
            {team:"한화", count: 0},
            {team:"두산", count: 0},
            {team:"키움", count: 0},
            {team:"롯데", count: 0},
            {team:"삼성", count: 0},
            {team:"LG", count: 0},
            {team:"kt", count: 0},
            {team:"KIA", count: 0},
            {team:"NC", count: 0},
            {team:"SK", count: 0}
          ];

          entry.forEach(element => {
            switch(element.팀) {
              case "한화":
                teamcount[0].count++;
                break;
              case "두산":
                teamcount[1].count++;
                break;
              case "키움":
                teamcount[2].count++;
                break;
              case "롯데":
                teamcount[3].count++;
                break;
              case "삼성":
                teamcount[4].count++;
                break;
              case "LG":
                teamcount[5].count++;
                break;
              case "kt":
                teamcount[6].count++;
                break;
              case "KIA":
                teamcount[7].count++;
                break;
              case "NC":
                teamcount[8].count++;
                break;
              case "SK":
                teamcount[9].count++;
                break;
            }
          });

          
          // teamcount is unsorted
          // order is given by number of player in entry
          teamcount.sort((a, b) => b.count - a.count);

          return teamcount;
        }


        // this function will change the menu into hitter
        function changeToHitter() {

          d3.select("#entry-view").selectAll("g").remove();
          d3.select("#substitute-svg").selectAll("g").remove();
          d3.select("#substitute-treemap-svg").selectAll("g").remove();

          this.innerText = "투수로 전환";
          this.onclick=changeToPitcher;
          is_hitter = true;

          _entrylist(entryhitter);
          gross_radar_graph_update();
          team_graph_update();

          // empty the selection in treemap
          let select_object = document.getElementById("substitute-treemap-select");
          select_object.options.length=0;
        }

        // this function will change the menu into pitcher
        function changeToPitcher() {

          d3.select("#entry-view").selectAll("g").remove();
          d3.select("#substitute-svg").selectAll("g").remove();
          d3.select("#substitute-treemap-svg").selectAll("g").remove();

          this.innerText = "타자로 전환";
          this.onclick=changeToHitter;
          is_hitter = false;

          _entrylist(entrypitcher);
          gross_radar_graph_update();
          team_graph_update();

          // empty the selection in treemap
          let select_object = document.getElementById("substitute-treemap-select");
          select_object.options.length=0;
        }

      })


    </script>

    <style>
      /* border for svgs */
      .outline:not(#flex-outline) {
        height: 800px;
        overflow: scroll;
      }
      #flex-outline {
        display: flex;
        width: 200%;
      }

      #entry-list-div {
        width: 260px;
        height: 750px;
      }

      #substitute-list-div {
        width: 160px;
        height: 750px;
      }

      #substitute-treemap-div {
        width: 820px;
        height: 750px;
      }

      #gross-team-graph-svg {
        width: 300px;
        height: 200px;
      }

      #compare-graph-div {
        display: flex;
        flex-direction: column;
        width: 600px;
      }

      #compare-graph {
        height: 300px;
      }
      
      svg {
        border: 1px solid black;
      }

      g.hover {
        font-weight: bold;
      }

    </style>

</body>